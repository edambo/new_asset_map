{
  "hash": "265ea8be806352992faa609454bf795b",
  "result": {
    "engine": "knitr",
    "markdown": "# Purpose\nThe purpose of this file is to ensure the data is in the appropriate format for\ncreating the dashboard in a visually appealing and meaningful way.\n\n# Load Libraries\n\n\n\n\n# Load data\n\n\n\n\n# Clean Data and add new variables\n\n## Clean the address data \n\n\n\n\n## Get geographical mapping data based on address zip codes\n\n::: {.cell}\n\n```{.r .cell-code}\n# Generate logitude and latitude data for each zipcode\nlong_lat <- geocode_zip(add_data$zipcode)\n\n# Manually add missing long and lat values for zipcode 78767\nlong_lat[4,2] <- 30.269806126148378 \nlong_lat[4,3] <- -97.73965108465788\n\n\n# Combine the long lat data with the rest of the address data\nadd_data <- add_data %>% left_join(., long_lat, by = \"zipcode\")\n```\n:::\n\n\n\n\n## Clean the program category data\n\n\n\n\n## Create variables for counts of programs for different categorizing methods.\n\n::: {.cell}\n\n```{.r .cell-code}\ncount_data <- cat_data %>%\n  # Create count by main category column\n  group_by(main_category) %>%\n  mutate(\n    count_by_main = n()\n  ) %>% relocate(count_by_main, .after = main_category) %>%\n  # Create count by subcategory column\n  group_by(main_category, sub_category) %>%\n  mutate(\n    count_by_sub = n()\n  ) %>% relocate(count_by_sub, .after = sub_category) %>%\n  ungroup() %>%\n  # Create count by intercept column overall\n  group_by(intercept) %>%\n  mutate(\n    count_by_int = n() \n  ) %>% \n  ungroup() %>%\n  # Create count by intercept column for each main category\n  group_by(main_category, intercept) %>%\n  mutate(\n    count_by_int_cat = n() \n  ) %>% \n  relocate(c(\"count_by_int\", \"count_by_int_cat\"), .after = intercept) \n  \n# Merge geographical data to categorical data and create counts by zip code \n# column  \ncat_geo <- add_data %>% left_join(., count_data, by = \"program\") %>%\n  # Count by zipcode overall\n  group_by(zipcode) %>%\n  mutate(\n    count_by_zip = n()\n  ) %>%\n  ungroup() %>%\n  # Count by zipcode for each main category\n  group_by(main_category, zipcode) %>%\n  mutate(\n    count_by_zip_cat = n()\n  ) %>%\n  ungroup() %>% \n  as.data.frame()\n```\n:::\n\n\n\n## Prepare the data, ensuring it's in the appropriate format for the plots\n### Create lists of factor levels for each main category\nThe factor levels are the subcategories ordered based on the count of programs \nwithin each category.They will include the full list of categories, not just the\ncategories in the actual data, so that if a category has no programs, it will\nstill show up in the plot of the subcategories as having a count of 0 instead\nof not appearing at all.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmain_cats <- cat_list %>% select(main_category) %>% distinct() %>% unlist()\n\nmc_levels_list <- list()\n\n# For each main category ...\nfor(mc in main_cats){\n  # From the actual data ...\n  dat <- cat_geo %>% filter(main_category == mc) %>%\n    # Add count of programs in each intercept and sort the intercepts by \n    # the counts\n    select(sub_category) %>% \n    add_count(sub_category, sort = TRUE) %>% select(sub_category) %>% \n    distinct() %>%\n    as.vector() %>% unlist()\n  # From the full list of categories ...\n  cats <- cat_list %>% filter(main_category == mc) %>% \n    # Create a list of all the existing sub_categories\n    select(sub_category) %>%\n    as.vector() %>% unlist()\n  # Combine the two lists, allowing only one of each sub_category to be present\n  # in the combined list\n  ml <- list(union(dat, cats))\n  # Iteratively fill the initialized list with each list for each main category\n  mc_levels_list <- append(mc_levels_list, ml)\n}\n# Name each nested list of subcategories by the associated main category\nnames(mc_levels_list) <- main_cats\n```\n:::\n\n\n### Apply created factor level lists, text, labels, select columns and convert df to sf\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# intercept levels\nint_levels <- levels(cat_geo$intercept)\n```\n:::\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create names for each main category dataframe\nmc_df_names <- c(\"bhs\", \"sut\", \"ha\", \"hcs\", \"cpi\", \"laa\", \"lds\", \"res\", \"cea\" )\n\n# Apply sub_plot_prep function to all the main categories\ndf_list <- lapply(names(mc_levels_list), sub_plot_prep) \n\n# Apply data frame names\nnames(df_list) <- mc_df_names\n\n# Split list of data frames\nlist2env(df_list, globalenv())\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<environment: R_GlobalEnv>\n```\n\n\n:::\n:::\n\n\n### Prepare the full data not broken down by main categories\n#### Create the factor list\n\n::: {.cell}\n\n```{.r .cell-code}\n# From the actual data ...\ndat <- cat_geo %>% \n  # Add count of programs in each  main category and sort the main categories by \n  # the counts\n  select(main_category) %>% \n  add_count(main_category, sort = TRUE) %>% select(main_category) %>% \n  mutate(\n    main_category = case_when(is.na(main_category) ~ \"Not Applicable\",\n    TRUE                                           ~ main_category)\n  ) %>%\n  distinct() %>%\n  as.vector() %>% unlist()%>% unname()\n\n# From the full list of categories ...\ncats <- cat_list %>% \n  # Create a list of all the existing subcategories\n  select(main_category) %>% distinct() %>%\n  as.vector() %>% unlist() %>% unname()\n# Get main categories in full list not in the data\nonly_cats <- list(setdiff(cats, dat)) %>% as.vector() %>% unlist()\n# Add these categories so that the last category is the \"NA\" category\nmain_cat_list <- append(dat, only_cats, after = 6)\n```\n:::\n\n\n#### Apply the factor list and add labels\n\n::: {.cell}\n\n```{.r .cell-code}\nprepped_mc_data <- cat_geo %>%\n  # select data columns that will be included in the dashboard\n  select(program, agency, main_category, count_by_main, sub_category, \n         intercept, intercept_code, count_by_int, \n         count_by_int_cat, zipcode, count_by_zip, count_by_zip_cat, lng, lat, \n         geometry) %>% \n  group_by(main_category) %>% \n  mutate(\n    # Convert \"NA\" to \"Not Applicable\n    main_category = case_when(is.na(main_category) ~ \"Not Applicable\",\n    TRUE                                           ~ main_category),\n    # Order the main category levels based on the count of programs\n    main_category = factor(main_category,\n                          levels = rev(main_cat_list))\n    )\n# Arrange the main categories by count\ntext_labels <-table(prepped_mc_data[\"main_category\"]) %>% as.data.frame() %>% rename(\n  count = Freq\n) %>% arrange(main_category) %>%\n  arrange(desc(count)) %>%\n  # Create labels\n  mutate(\n    text_label = paste(\"Need category: \", main_category, \"<br>Programs: \", count) \n  )\n\n# Apply factor levels\ntext_labels <- text_labels[match(main_cat_list, text_labels[[\"main_category\"]]),] %>% \n  select(text_label) %>%\n  as.vector() %>% unlist() %>% unname()\n\n# Create intercept labels and arrange the intercept categories by count\nint_text_labels <-table(prepped_mc_data[\"intercept\"]) %>% as.data.frame() %>% rename(\n  count = Freq\n) %>% arrange(intercept) %>%\n  arrange(desc(count)) %>%\n  # Create labels\n  mutate(\n    int_text_label = paste(\"Intercept: \", intercept, \"<br>Programs: \", count) \n  ) %>% \n  select(int_text_label) %>% unlist() %>% unname()\n\n# Combine text labels with prepped data\nall <- prepped_mc_data %>% \n  mutate(\n    main_cat_text = factor(main_category, levels = rev(main_cat_list), \n                          labels = rev(text_labels)),\n    int_cat_text = paste(\"Intercept: \", intercept, \"<br>Programs: \", count_by_int),\n    int_cat_text  = factor(int_cat_text,\n                           levels = rev(int_text_labels))\n    ) %>% sf::st_as_sf()\n```\n:::\n\n\n# Save data\n\n::: {.cell}\n\n```{.r .cell-code}\npath <- here::here(\"data\", \"prepped_data.RData\")\nsave(all, bhs, sut, ha, hcs, cpi, laa, lds, res, cea, file = path)\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}